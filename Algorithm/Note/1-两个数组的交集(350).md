# 第350题: 两个数组的交集

## 题目: 给定两个数组，编写一个函数来计算它们的交集

### 例如

```Python
输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
```

### 说明

* 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
* 我们可以不考虑输出结果的顺序。

### 原题自己的思路

先分别遍历两个数组，将出现过的元素统计起来。用数组存放起来，第一行为去重过后的数组元素，第二行为对应列的元素出现的次数。然后将两个去重过后的数组分别排序，然后从小到大比较元素来确定两个数组中都有的元素以及他们出现的次数，最后交集中的元素的次数应该以较小的出现次数为准。

### 原题小浩的解题分析

首先拿到这道题，我们基本马上可以想到，此题可以看成是一道传统的映射题（map映射），为什么可以这样看呢，因为我们需找出两个数组的交集元素，同时应与两个数组中出现的次数一致。这样就导致了我们需要知道每个值出现的次数，所以映射关系就成了`<元素,出现次数>`。剩下的就是顺利成章的解题。

### 原题自己修改之后的思路

首先遍历其中的一个数组，将它映射成`<元素,出现次数>`的组合，然后遍历第二个数组，按照映射关系确定的元素顺序来对第二个数组进行遍历，如果这个正在遍历的元素在第二个数组中出现了，则将这个数保留，并将出现次数减一，如果没有出现则继续向后遍历直到第二个数组遍历完成。这个程序将会在映射关系确定的数组遍历完成之后结束。这个方法相较于之前的方法有了明显的复杂度上的降低。因为原来的方法是要遍历两个数组并且两个数组都要映射成这种关系，而且还要排序才能决定去重的关系，但是这个方法只需要遍历一个数组，然后拿着遍历之后的结果去查找第二个数组，这样的话既节省了空间也节省了时间。

## 进阶

* 如果给定的数组已经排好序呢？将如何优化你的算法呢？

### 进阶题自己的思路

因为给定的两个数组是排好序的，所以在去重的难度上有所降低，在遍历数组上花费的次数会显著变少。假设他给的数组是从小到大排列的，我就给两个数组分别设置一个指针，这两个指针的初始位置在数组的`[0]`位置上，然后比较指针所指位置的元素的大小，如果a指针所指的元素小于b指针所指的元素，那么a指针舍弃掉目前所指的元素并向后移动一个单位，因为这说明a指针所指位置的元素已经是这两个集合中最小的元素并且在b指针所指的数组中没有和它一样大的元素；如果a和b指针所指的元素大小相同，则把这个元素放进交集的数组中，a和b指针都向后移动一个单位。

### 进阶题小浩的思路

设定两个为0的指针，比较两个指针的元素是否相等。如果指针的元素相等，我们将两个指针一起向后移动，并且将相等的元素放入空白数组。
> 可以看到这里我们两个的思路是差不多的。

## 原题解题方法

### 力扣给出的答题模板

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

#### 复习vector\<int\>的用法

```c++
vector<int> nums;//不指定长度创建vector
vector<int> nums(n);//创建一个长度为n的vector

nums.push_back(value);//用push_back方法向vector的末端添加一个值为value的元素
nums[i] = value;//将vector的第i个位置上的元素赋值为value

nums.resize(nums.size-i);//将数组的长度减小i，直接舍弃掉vector的后i个元素
nums.pop_back();//用pop_back方法删除vector的最后一个元素

nums.size()//用size()函数可以获得此时vector的长度
```

#### 复习二维vector的用法

```c++
vector<vector<int> > A;//正确地定义二维vector的方式，注意>之间的空格

//要记得A的元素是一维vector，所以在插入的时候需要插入vector
vector<int> B;
B.push_back(0);
B.push_back(1);
B.push_back(2);
A.push_back(B);
```

二维vector其实就是以一维vector为元素的vector。

### 力扣给出的哈希表代码

```c++
class Solution {
public:
    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()) {
            return intersect(nums2, nums1);
        }
        unordered_map <int, int> m;
        for (int num : nums1) {
            ++m[num];
        }
        vector<int> intersection;
        for (int num : nums2) {
            if (m.count(num)) {
                intersection.push_back(num);
                --m[num];
                if (m[num] == 0) {
                    m.erase(num);
                }
            }
        }
        return intersection;
    }
};
```

#### unordered_map的用法

1. 直接初始化

    ```c++
    unordered_map <int, int> m;//定义一个键和值都为int类型的无序map
    ```

2. 使用已经存在的无序map来初始化，调用内置的拷贝函数

    ```c++
    unordered_map <int, int> m(existed_map);
    ```

3. 还有其他的初始化方法，这里不一一列出。
