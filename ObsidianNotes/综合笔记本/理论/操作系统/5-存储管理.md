逻辑地址（相对地址，虚地址）：用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式。

* 其首地址为0，其余指令中的地址都相对于首地址来编址
* 不能用逻辑地址在内存中读取信息

物理地址（绝对地址，实地址）：内存中存储单元的地址。物理地址可直接寻址。

地址映射：将用户程序中的逻辑地址转换为运行时由机器直接寻址的物理地址。

* 当程序装入内存时，操作系统为该程序分配一个内存空间，由于程序的逻辑地址与分配到的内存物理地址不一致，而CPU执行指令时，是按物理地址进行的，所以需要进行地址转换。

## 存储管理的功能

1. 存储分配和回收：按照一定的策略为并发进程分配内存空间，并回收系统或用户释放的空间。
2. 地址变换：将程序地址空间中使用的逻辑地址变成主存中的地址
   * 程序加载（装入）时的重定位技术
   * 运行时硬件和软件的地址变换机构和技术
3. 存储共享和保护：
   * 代码和数据的共享，提高内存的利用率
   * 限制只在各自的存储区域内操作，互不干扰
4. 存储器扩充方式（通过内、外存之间交换程序或数据段）
   * 覆盖
   * 交换
   * 请求调入/预调入

## 存储分配的方式

1. 直接分配：程序员在编写程序时，或编译程序对源程序进行编译时，直接使用实际的存储地址。
   * 前提：事先确定一个作业在主存中的位置
   * 缺点：存储空间的利用率不高，且不方便
2. 静态分配：程序装入内存时才确定在内存中的位置，且在其整个运行期间不能在内存中移动，也不能再申请内存空间。
   * 前提：程序装入内存时必须分配所要求的全部存储量，且退出前不释放
   * 缺点：在多道程序系统中不能有效地共享存储器资源
3. 动态分配：程序装入内存时才确定它们在内存中的位置，但在其整个运行期间可以再申请内存空间，也可在内存中移动。一个程序已占有的存储区不再需要时，可以归还给系统。
4. 重定位（地址映射）：在可执行文件装入时需要解决可执行文件中地址（包含指令和数据的地址）和内存地址的对应。

## 程序载入的方式

1. 绝对装入：编程或编译时确定地址映射关系

   直接按物理内存地址编程，这种程序在系统中是不能做任何移动的，否则就会出错。

   * 优点：装入过程简单
   * 缺点：不灵活、不适于多道程序系统

2. 静态地址映射：在程序装入内存时完成从逻辑地址到物理地址的转换。

   由装入程序（加载程序）负责将用户程序装入系统，并将用户程序中使用的逻辑地址转换成物理地址。

   * 优点：实现简单，不要硬件的支持
   * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，不易实现共享

3. 动态地址映射：动态地址映射是在程序执行时由系统硬件完成从逻辑地址到物理地址的转换。

   1. 动态地址映射是在执行时完成的，程序中不执行的程序就不做地址映射的工作，这样节省了CPU的时间
   2. 实现动态地址映射必须有硬件的支持

   重定位寄存器：由操作系统用特权指令来设置，比较灵活。

   * 优点：程序段可进行非连续分配
   * 可部分地、动态地分配内存
   * 有利于程序段的共享

## 内存信息的共享和保护

在多道程序设计的环境下，内存中的系统程序、用户程序和数据段可供不同的用户进程共享——以提高内存利用率。

另外，又要限制各进程只在自己的存储区活动（除了被允许共享的部分外）——以保证不对其他进程的程序和数据段产生干扰和破坏。因此，需采用存储保护的措施。

### 目的

* 保护系统程序区不被用户侵犯（有意或无意的）
* 不允许用户程序读写不属于自己地址空间的数据（系统区地址空间，其他用户程序的地址空间）

### 类型

* 界限保护（上界/下界寄存器或基址/限长寄存器）
* 访问方式保护（保护键）

### 界限保护

每个进程都有自己独立的进程空间，如果一个进程在运行时所产生的地址在其地址空间之外，则发生地址越界。

当程序要访问某个内存单元时，由硬件检查是否允许，如果允许则执行，否则产生地址越界中断，由操作系统进行相应处理。

* 上界/下界寄存器

  所有访问地址必须在上下界之内

* 基址/限长寄存器

  所有访问地址必须在界限范围内

### 访问方式保护

对于允许多个进程共享的存储区域，每个进程都有自己的访问权限。如果一个进程对共享区域的访问违反了权限规定，则发生操作越权（即读写保护）。

为每一个被保护内存区域指定保护键和若干禁止的访问方式，同时进程指定保护键开关。如果访问时键值不匹配而且是被禁止的访问方式，则产生访问出错中断。

## 虚拟存储器

为用户提供一种不受物理存储器结构和容量限制的存储技术。

使得用户编程时不需要考虑物理内存的结构和容量；每个进程都拥有自己的虚存，且虚存大小不受实际物理存储器的限制。

### 物质基础

两级存储结构（内存和外存）；地址变换机构（实现逻辑地址到物理地址的转换）。

### 原理

* 在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分读入到内存，便可让程序开始执行（程序的一部分在内存就可执行）
* 在程序执行过程中，如果需执行的指令或访问的数据尚未在内存，则由处理器通知操作系统将相应的程序段或数据调入到内存，然后继续执行程序
* 另一方面，将内存中暂时不使用的程序段或数据调出保存在外存上，从而腾出空间存放将要装入的程序及数据

### 类别

页式管理、段式管理、段页式管理。

## 内外存数据传输的控制

### 应用程序控制

#### 覆盖

##### 原理

一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。

* 将程序的必要部分（常用功能）的代码和数据常驻内存
* 可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中，在需要时才装入到内存
* 不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖（即不同时用的模块可共用一个分区）
* 可与分区存储管理配合使用

##### 缺点

* 用户负担大（要求用户清楚地了解程序的结构，并指定各程序段调入内存的先后次序）
* 程序段的最大长度仍受内存容量限制
* 不能实现虚拟存储器

### 操作系统控制

#### 交换

##### 原理

将暂时不能执行的程序或就绪状态的进程送到外存中，从而获得空闲内存空间来装入新程序。

* 程序暂时不能执行的可能原因：处于阻塞状态，低优先级（确保高优先级程序执行）
* 交换单位为整个进程的地址空间
* 常用于多道程序系统或小型分时系统中，与分区存储管理配合使用

##### 换出

暂停内存中进程的执行，将其整个地址空间保存到外存的交换区中。

##### 换入

将外存中由阻塞变为就绪的进程的地址空间读入到外存中，并将该进程送到就绪队列。

#### 虚拟存储

##### 请求调入

请求调入方式是在程序执行时，如果所要访问的程序段或数据段不在内存中，则操作系统自动地从外存将有关的程序段和数据段调入内存。

##### 预调入

预调入方式是由操作系统预测在不远的将来会访问到的那些程序段和数据段部分，并在它们被访问之前系统选择适当的时机将它们调入内存。

## 分区存储管理

### 原理

把内存分为一些大小相等或不等的分区，除操作系统占用一个分区外，其余分区用来存放进程的程序和数据。

特点：适用于多道程序系统和分时系统（最简单）

* 支持多个程序并发执行
* 难以进行内存分区的共享

问题：可能存在内碎片和外碎片

* 内碎片：占用分区之内未被利用的空间

* 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）

### 分区管理

#### 固定分区法

作业执行前把内存固定地划分区域。

缺点：存在大量碎片，主存利用率低。

##### 原理

* 分区大小可以相等也可以不相等

  分区大小不等：

  * 多个小分区，适量的中等分区，少量的大分区
  * 根据程序的大小，分配当前空闲的、适当大小的分区

* 分区个数不变，大小不变

##### 内存分配管理

* 数据结构：

  分区说明表（分区号、分区大小、起始地址、分区状态）

* 由内存分配程序检索分区说明表，找到符合要求的分区

#### 动态分区法

在作业的处理过程中划分区域

##### 原理

位置和大小都不固定，应作业的要求而设置。

##### 数据结构

* 空闲分区表（可用表）
* 空闲分区链（自由链）
* 请求表：描述请求内存资源的作业或进程号及所请求的内存大小。

#### 固定分区的分配与回收

存储管理程序根据请求表查询分区说明表，从中找出一个满足要求的空闲分区，并将其分配给申请者。

#### 动态分区的分配

* 从可用表/自由链中找到一个足以容纳该作业的可用空白区
* 若这个空白区比所需求大，则将它分成两个部分：一部分成为已分配区，剩下部分仍为空白区
* 修改可用表或自由链，并回送一个所分配区的序号或该分区的起始地址

##### 最先匹配法

按分区起始地址的递增次序，从头查找，找到符合要求的第一个分区

##### 最佳匹配法

按分区大小的递增次序， 查找，找到符合要求的第一个分区

##### 最坏匹配法

按分区大小的递减次序，从头查找，找到符合要求的第一个分区

#### 动态分区的回收

* 检查回收的分区是否与空白区邻接，如有则加以合并，使之成为一个连续的大空白区
* 修改可用表或自由链

### 优缺点

#### 优点

* 实现了多个作业或进程对内存的共享
* 要求的硬件支持少，管理算法简单，易实现

#### 缺点

* 内存利用率不高，主要是碎片问题

* 作业的大小或进程大小受分区大小限制

  整体装入、连续存放

* 难以实现各分区间的信息共享

  各作业或进程对应于不同的分区

## 页式存储管理

### 基本原理

#### 逻辑空间分页

程序地址空间分成大小相等的页（页面的大小为$2^n$，通常为1KB，2KB，nKB等）。每页都有一个页号，从0开始编排。

#### 内存空间分块

把内存也按页的大小分成内存块或页面，同样从0开始编排。

#### 内存分配原则

当一个用户程序装入内存时，以页为单位进行分配，并且一个进程的若干页可分别装入物理上不相邻的内存块中。

### 逻辑地址的表示

在分页存储管理中，用户程序中的逻辑地址包括页号和页内地址（页内位移）。

如果给定页面大小为L，逻辑地址是A，则页号和页内位移可按下式计算：
$$
P=INT[A/L]\\
d=A\% L
$$

### 页表

页式存储管理的数据结构，它包括用户程序空间的页面与内存块的对应关系、页面的存储保护和存取控制方面的信息。

### 页式地址映射

* 页号=INT[虚地址/页大小]
* 位移量=虚地址 mod 页大小
* 产生页表
* 以页号查页表，得到对应的内存块号
* 内存地址=块号x页大小+位移量

### 请求页式存储管理

纯页式（静态）存储管理提高了内存的利用效率，但并不为用户提供虚存。为此，提出了请求分页（动态）存储管理技术。

#### 思想

和纯分页的相同点：逻辑空间分页，内存空间分块。

和纯分页的不同点：请求分页技术当一个用户程序要调入内存时，不是将该程序全部装入内存，而是只装入部分页到内存，就可启动程序运行，在运行的过程中，如果发现要运行的程序或要访问的数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将在外存相应的页调入内存，使该程序继续运行。

#### 要解决的问题

如何发现执行的程序或访问的数据不在内存

调入策略，程序或数据什么时候调入内存

淘汰策略，当一些页调入内存时，内存没有空闲内存，将淘汰哪些页。

#### 调入策略

##### 预调

系统根据作业（进程）运行的情况，预测哪些页将要运行，在其运行之前先行调入内存（系统很难完全预计作业的运行情况，因此难以实现）。

##### 请调

进程在执行的过程中，发现要执行的程序或要处理的数据不在内存时，产生缺页中断（此时用户进程被中断，转OS的调页程序把外存中相应的页面调入内存）。

#### 淘汰策略的评价指标

缺页次数和缺页率（缺页率为缺页次数与总访问次数之比）。

#### 置换算法

##### 随机淘汰算法

当无法确定哪些页被访问的概率较低时，随机地选择某个用户的页并将其换出。

通常选出的被淘汰的页面应该是访问概率最低的页。

##### 轮转法

循环换出内存可用区内一个可以被换出的页，无论该页是刚被换进或已换进内存很长时间。

##### FIFO先进先出法

选择在内存驻留时间最长的页将其淘汰

* 先进入内存的页，先退出内存（最早调入内存的页，不再被使用的可能性比较大）
* 算法简单、实现容易。

##### 最近最久未使用页面（LRU）置换算法

基本思想：当需要淘汰某一页时，选择离当前时间最近的一段时间内最久没有使用过的页先淘汰。即当需要淘汰一页时，选择最长时间未使用的页。

基于假设：

* 如果某页被访问，他可能马上还要被访问
* 如果某页长时间未被访问，他可能最近也不可能被访问

算法的实现：为每页设置一个特定的单元，用于记录自上次访问以来所经历的时间t，当需要置换一页时，选择t最大的淘汰。

完全实现LRU算法需要花费巨大的系统开销（必须对每一个页面都设置有关的访问记录项，而且每一次访问都必须更新这些记录）。实际系统中往往使用LRU的近似算法。

