## 程序的基本概念

1. 程序执行的两种方式：顺序执行、并发执行（现代操作系统多为并发执行，引入并发执行的目的是提高资源利用率）
2. 顺序执行：一个计算的若干操作必须按照严格的先后次序顺序地执行，这类计算过程就是程序的顺序执行过程。
3. 并发执行：指一组在逻辑上相互独立的程序或程序段在执行过程中，其执行时间在客观上相互重叠，即一个程序段的执行尚未结束，另一个程序段的执行已经开始的这种执行方式。

## 进程的基本概念

### 定义

进程是指一个具有独立功能的程序对某个数据集在处理机上的执行过程和分配资源的基本单位。

### 进程和程序的区别

1. 进程是动态的，程序是静态的

   程序本身可以作为软件资源而长期存在，进程是程序的一次执行过程，有一定的生命周期。

2. 进程具有并发特征，而程序没有

   进程是一个能够独立运行的单位，是作为资源申请和调度单位存在的，能与其他进程并发执行；程序不能作为一个独立运行的单位而并发执行。

3. 程序和进程没有一一对应关系

   通过多次执行，一个程序可对应多个进程。

   通过调用关系，一个进程可包括多个程序。

4. 各个进程在并发执行过程中会产生相互制约关系

   因为进程是竞争资源的基本单位，从而其并发性受到系统自己的制约，而程序没有这种限制。

### 进程的组成

进程通常由程序、数据集合和进程控制块PCB三部分组成。程序和它操作的数据是进程存在的静态实体，而专门的数据结构PCB用来描述进程当前的状态、本身的特性等。

### 进程的状态

1. 就绪状态：处于就绪状态的进程已经得到除CPU之外的其他资源，只要由调度得到处理机，便可立即投入执行。
2. 运行状态：进程调度程序从就绪队列中选择一个进程分配给它CPU控制权，该进程所处的状态为运行状态。
3. 等待状态：进程因等待某个事件的发生（如等待I/O的完成），而暂停执行，则该进程处于等待状态（这时，即使给它CPU，它也无法执行）。

### 进程的相互作用

多道程序的环境中，系统中的多个进程可以并发执行，同时它们又要共享系统中的资源。这些资源有些是可共享使用的，如磁盘；有些是以独占方式使用的，如打印机。由此将会引起一系列的矛盾，产生错综复杂的相互制约的关系。

#### 进程互斥

1. 临界资源：一次仅允许一个进程使用的资源称为临界资源。
2. 临界区：每个进程中访问临界资源的那段程序段称为临界区。
3. 互斥的定义：在操作系统中，当某一进程正在访问某临界区时，就不允许其它进程进入，进程之间的这种相互制约的关系称为互斥。

在某一个进程占用了只允许一个进程使用的资源之后，这个资源不允许其他进程访问的现象称为进程互斥。跟精子和卵子相似，精子为进程，卵子为资源，当一个精子率先进入卵子之后卵子就不再允许其他精子进入。

#### 进程同步

异步环境下的一组并发进程互相发送消息而进行互相合作、互相等待，使得各进程在执行速度上相互协调，这样的相互制约关系称为进程同步。

两个进程之间互相有仰仗另一个进程的地方，既不能执行的超前，因为需要另一个进程给他提供继续执行所必需的资源；也不能执行的滞后，无法给另一个进程提供资源。

#### 同步与互斥的关系

##### 相同点

进程的同步与互斥都涉及到并发进程共享资源的问题，实际上进程的互斥是同步的一种特殊情况。

##### 不同点

互斥的概念来自于各个进程对独占使用资源的竞争，同步则来源于多个进程的合作。

进程互斥是进程间竞争共享资源的使用权，这种竞争没有固定的必然关系，各个进程的执行顺序可以是任意的。哪个进程先竞争到使用权就归哪个进程先使用。

进程同步是共享资源的并发进程间的一种合作关系。此时，即时无进程在使用共享资源，尚未得到同步消息的进程也不能去使用这个资源。

#### 死锁

##### 定义

指各并发进程彼此相互等待对方所拥有的资源，且这些并发进程在得到对方的资源之前不会释放自己所拥有的资源。从而造成大家都想得到资源而又都得不到资源，各并发进程不能继续向前推进的状态。

##### 必要条件

互斥条件（资源是不可共享的临界资源，进程要求对所分配的资源进行排他性控制）。

部分分配（进程每次申请它所需要的一部分资源，在等待新资源的同时，继续占有已经分配到的资源）。

不剥夺条件（进程已经获得资源，在没有使用完之前不能被剥夺）。

环路条件（在发生死锁时，必然存在一种进程-资源的循环链，链中每一个进程已获得的资源同时被下一个进程所请求）。

##### 安全状态

现有进程资源占有的情况下，各进程按照某种推进顺序仍然可以使每个进程得到其对资源的最大需求，从而都可以顺利地完成。

* 并非所有不安全状态都是死锁，但进入不安全状态可能导致死锁。
* 只要处于安全状态便避免了死锁，因此应该尽量考虑避免进入不安全状态。

##### 死锁的排除方法

###### 预防死锁

采取某种策略，限制并发进程对资源的请求，从而破坏产生死锁的必要条件中的一个或者几个来防止发生死锁。

###### 避免死锁

系统在分配资源时，根据资源的使用情况提前做出预测，从而避免发生死锁。

###### 检测与解除死锁

系统设有专门的机构，当发生死锁时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁中恢复出来。

##### 预防死锁的方法

1. 资源预先分配策略

   运行前（创建时），一次性分配给进程它所需的全部资源。如果某个进程所需要的全部资源得不到满足时，则不分配任何资源，此进程暂不运行。由于等待期间的进程不占有任何资源，因此避免发生死锁。

   * 优点：简单易实现且安全。
   * 缺点：浪费资源，进程延迟运行，降低了进程的并发性。

2. 资源的有序分配

   把系统资源按照类型排序（例如打印机为1，磁带机为2，磁盘为3等），进程要按照资源的序号递增的次序提出资源申请。

   * 优点：综合性能较好
   * 缺点：限制了进程对资源的请求，同时给系统中所有资源编号增加了系统开销。固定访问顺序不一定合理，可能会造成资源的浪费。

3. 银行家算法

   实质就是要设法保证系统动态分配资源后仍然保持安全状态，从而避免死锁的发生。要求进程预先告知自己的最大资源需求，并且假设系统拥有固定的资源总量。

##### 银行家算法

###### 数据结构

* 可用资源向量（available）：m个元素的数组，每个元素代表一类可利用的资源数，如available[i]=k，初始值为系统中该类全部可用的资源数

* 最大需求矩阵（max）：$n\times m$阶矩阵，如max(i,j)=k代表系统中进程i对j类资源的最大需求数目为k

* 占有矩阵（allocation）：$n\times m$阶矩阵，各进程对各类资源还需要的数量，如need(i,j)=k

  > 上述矩阵存在下列关系：
  >
  > need(i,j)=max(i,j)-allocation(i,j)

###### 步骤

设$Request_i$是进程$P_i$的请求向量，$Request_i(j)=k$表示进程$P_i$请求分配$R_j$类资源$k$个，当$P_i$发出资源请求后，系统按照下列步骤进行检查

1. 若$Request_i\leq Need$，继续；否则出错（系统会因为它所需要的资源数已超过它要求的最大值而认为出错）。

2. 若$Request_i\leq Available$，继续；否则出错（系统会因为系统中没有足够的资源满足$P_i$的申请而使进程$P_i$等待）。

3. 试探性分配：系统试探地把资源分配给进程$P_i$并修改如下数据结构中的值：
   $$
   Available=Available-Request_i\\
   Allocation_i=Allocation_i+Request_i\\
   Need_i=Need_i-Request_i
   $$

4. 系统执行安全算法，检查此次资源分配后，系统是否处于安全状态。若是，则系统真正将资源分配给进程$P_i$以完成本次分配；若不是，则将上述矩阵中保存的状态返回原状态，让$P_i$等待。

##### 安全性算法

1. 设置两个向量

   * 工作向量Work：m个元素的数组，表示 系统可提供给进程继续运行所需的各类资源数目，初值Work=Available。
   * 完成向量Finish：n个元素的数组，记录当前n个并发进程是否完成，true表示完成，false表示还没有完成。

2. 从进程集合中找到一个能满足下述条件的进程
   $$
   Finish(i)=false\\
   Need_i\leq Work
   $$

3. 当进程$P_i$获得资源后可顺利执行直到完成，然后释放分配给它的资源，并做如下工作：
   $$
   Work=Work+Allocation\\
   Finish(i)=true
   $$

4. 若所有进程的Finish(i)的值都为true，则说明系统处于安全状态；否则系统处于不安全状态。
